

# Text File Handling and Modification





In this extended section, we'll cover commands that are vital for working with text files:

- **Creating files with `touch`**
- **Viewing and concatenating files with `cat`**
- **Displaying parts of files with `head` and `tail`**
- **Paging through files with `less`**
- **Counting words, lines, and characters with `wc`**
- **Numbering lines with `nl`**
- **Sorting file contents with `sort`**
- **Comparing files with `diff`**



---

## Part : Basic Text File Operations

### The `touch` Command

####  Introduction to `touch`

The `touch` command is used to create empty files or update the access and modification timestamps of existing files.

**Key Features:**

- **Create empty files**: Quickly generate new, empty files.
- **Update timestamps**: Modify the access and modification times of existing files.

#### Basic Syntax

```bash
touch [OPTIONS] FILE...
```

- **`FILE...`**: One or more files to create or update.

####  Commonly Used Options**

- **`-a`**: Change only the access time.
- **`-m`**: Change only the modification time.
- **`-t [[CC]YY]MMDDhhmm[.ss]`**: Use the specified time instead of the current time.
- **`-c`** or **`--no-create`**: Do not create any files; only modify existing ones.

####  Examples

- **Create an empty file named `newfile.txt`:**

  ```bash
  touch newfile.txt
  ```

- **Update the modification time of `existingfile.txt`:**

  ```bash
  touch existingfile.txt
  ```

- **Set the access and modification time to a specific date and time:**

  ```bash
  touch -t 202309151230.00 file.txt
  ```

  - Sets the timestamp to September 15, 2023, at 12:30:00.

- **Change only the access time:**

  ```bash
  touch -a file.txt
  ```

- **Update timestamps of multiple files:**

  ```bash
  touch file1.txt file2.txt file3.txt
  ```

#### ** Practical Applications**

- **Creating placeholder files in scripts:**

  ```bash
  touch /tmp/process_started.lock
  ```

- **Updating timestamps to trigger build systems or backups:**

  ```bash
  touch source_code.c
  ```

---

### ** The `cat` Command**

#### ** Introduction to `cat`**

The `cat` command, short for **concatenate**, is used to read and concatenate files, writing their contents to the standard output.

**Key Features:**

- **Display file contents**: View the content of files.
- **Concatenate files**: Combine multiple files into one.
- **Create files**: Redirect output to create new files.

#### ** Basic Syntax**

```bash
cat [OPTIONS] [FILE...]
```

- **`FILE...`**: One or more files to read.

#### ** Commonly Used Options**

- **`-n`** or **`--number`**: Number all output lines.
- **`-b`** or **`--number-nonblank`**: Number non-empty output lines.
- **`-s`** or **`--squeeze-blank`**: Suppress repeated empty output lines.
- **`-E`** or **`--show-ends`**: Display `$` at the end of each line.
- **`-T`** or **`--show-tabs`**: Display tabs as `^I`.

#### ** Examples**

- **Display the contents of a file:**

  ```bash
  cat file.txt
  ```

- **Concatenate multiple files and display the result:**

  ```bash
  cat file1.txt file2.txt
  ```

- **Create a new file by concatenating files:**

  ```bash
  cat file1.txt file2.txt > combined.txt
  ```

- **Append a file to another:**

  ```bash
  cat file2.txt >> file1.txt
  ```

- **Number all output lines:**

  ```bash
  cat -n file.txt
  ```

- **Display content with non-printing characters:**

  ```bash
  cat -v file.txt
  ```

#### ** Practical Applications**

- **Quickly viewing small files:**

  ```bash
  cat README.md
  ```

- **Merging configuration files:**

  ```bash
  cat config_part1.conf config_part2.conf > full_config.conf
  ```

- **Displaying file contents with line numbers (useful for debugging scripts):**

  ```bash
  cat -n script.sh
  ```

---

### ** The `head` Command**

#### ** Introduction to `head`**

The `head` command outputs the first part of files. By default, it displays the first 10 lines.

**Key Features:**

- **Preview files**: See the beginning of files without opening them.
- **Control number of lines or bytes displayed**.

#### ** Basic Syntax**

```bash
head [OPTIONS] [FILE...]
```

#### ** Commonly Used Options**

- **`-n NUM`** or **`--lines=NUM`**: Print the first `NUM` lines.
- **`-c NUM`** or **`--bytes=NUM`**: Print the first `NUM` bytes.

#### ** Examples**

- **Display the first 10 lines (default):**

  ```bash
  head file.txt
  ```

- **Display the first 20 lines:**

  ```bash
  head -n 20 file.txt
  ```

- **Display the first 50 bytes:**

  ```bash
  head -c 50 file.txt
  ```

- **Display the first lines of multiple files:**

  ```bash
  head file1.txt file2.txt
  ```

#### ** Practical Applications**

- **Previewing large files:**

  ```bash
  head large_data.csv
  ```

- **Checking file headers or formats:**

  ```bash
  head sequences.fasta
  ```

---

### ** The `tail` Command**

#### ** Introduction to `tail`**

The `tail` command outputs the last part of files. By default, it displays the last 10 lines.

**Key Features:**

- **View the end of files**: Useful for logs and real-time monitoring.
- **Follow file updates in real-time**.

#### ** Basic Syntax**

```bash
tail [OPTIONS] [FILE...]
```

#### ** Commonly Used Options**

- **`-n NUM`** or **`--lines=NUM`**: Print the last `NUM` lines.
- **`-c NUM`** or **`--bytes=NUM`**: Print the last `NUM` bytes.
- **`-f`** or **`--follow`**: Output appended data as the file grows.
- **`-F`**: Same as `-f` but with additional handling when files are renamed or rotated.

#### ** Examples**

- **Display the last 10 lines (default):**

  ```bash
  tail file.txt
  ```

- **Display the last 20 lines:**

  ```bash
  tail -n 20 file.txt
  ```

- **Follow a log file in real-time:**

  ```bash
  tail -f /var/log/syslog
  ```

- **Display the last lines of multiple files:**

  ```bash
  tail file1.txt file2.txt
  ```

#### ** Practical Applications**

- **Monitoring log files for errors:**

  ```bash
  tail -f application.log
  ```

- **Checking the completion of data processing:**

  ```bash
  tail output.txt
  ```

- **Watching real-time output from a running process:**

  ```bash
  tail -f process_output.log
  ```

---

### ** The `less` Command**

#### ** Introduction to `less`**

The `less` command is a terminal pager used to view (but not modify) the contents of a text file one screen at a time. It's more advanced and feature-rich than `more`.

**Key Features:**

- **Efficient file viewing**: Doesn't need to read the entire file before starting.
- **Navigation**: Allows backward and forward movement in the file.
- **Search functionality**: Supports searching within the file.

#### ** Basic Syntax**

```bash
less [OPTIONS] [FILE]
```

#### ** Commonly Used Options**

- **`-N`** or **`--LINE-NUMBERS`**: Display line numbers.
- **`-S`** or **`--chop-long-lines`**: Chop long lines rather than wrapping.
- **`-X`**: Prevent clearing the screen on exit.
- **`-F`** or **`--quit-if-one-screen`**: Exit if the output fits on one screen.

#### ** Navigation Commands in `less`**

- **`Space`**: Scroll forward one screen.
- **`b`**: Scroll backward one screen.
- **`Enter`**: Scroll forward one line.
- **`y`**: Scroll backward one line.
- **`g`**: Go to the beginning of the file.
- **`G`**: Go to the end of the file.
- **`/pattern`**: Search forward for "pattern".
- **`?pattern`**: Search backward for "pattern".
- **`n`**: Repeat the previous search forward.
- **`N`**: Repeat the previous search backward.
- **`q`**: Quit `less`.

#### ** Examples**

- **View a file:**

  ```bash
  less file.txt
  ```

- **Display line numbers:**

  ```bash
  less -N file.txt
  ```

- **Chop long lines instead of wrapping:**

  ```bash
  less -S file.txt
  ```

- **Open `less` and search for a pattern immediately:**

  ```bash
  less +/pattern file.txt
  ```

#### ** Practical Applications**

- **Viewing large log files:**

  ```bash
  less /var/log/syslog
  ```

- **Reading documentation files:**

  ```bash
  less README.md
  ```

- **Examining the output of a command:**

  ```bash
  ps aux | less
  ```

---

### ** The `more` Command**

#### ** Introduction to `more`**

The `more` command is a simple pager for viewing text files. It displays text one screen at a time.

**Key Features:**

- **Basic file viewing**: Scroll through text files.
- **Simpler than `less`** but with fewer features.

#### ** Basic Syntax**

```bash
more [OPTIONS] [FILE]
```

#### ** Navigation Commands in `more`**

- **`Space`**: Scroll forward one screen.
- **`Enter`**: Scroll forward one line.
- **`b`**: Scroll backward one screen (if supported).
- **`q`**: Quit `more`.
- **`/pattern`**: Search forward for "pattern".

#### ** Examples**

- **View a file:**

  ```bash
  more file.txt
  ```

- **View command output with paging:**

  ```bash
  ls -l | more
  ```

#### ** Practical Applications**

- **Quickly viewing files when `less` is not available.**

---

### ** The `wc` Command**

#### ** Introduction to `wc`**

The `wc` (word count) command counts the number of lines, words, and bytes in files.

**Key Features:**

- **Count lines, words, characters, and bytes.**
- **Useful for statistics and validations.**

#### ** Basic Syntax**

```bash
wc [OPTIONS] [FILE...]
```

#### ** Commonly Used Options**

- **`-l`**: Count lines.
- **`-w`**: Count words.
- **`-c`**: Count bytes.
- **`-m`**: Count characters.
- **`-L`**: Display length of the longest line.

#### ** Examples**

- **Count lines, words, and bytes (default behavior):**

  ```bash
  wc file.txt
  ```

- **Count only lines:**

  ```bash
  wc -l file.txt
  ```

- **Count words in multiple files:**

  ```bash
  wc -w file1.txt file2.txt
  ```

- **Count characters from standard input:**

  ```bash
  echo "Hello World" | wc -m
  ```

#### ** Practical Applications**

- **Counting the number of sequences in a FASTA file:**

  ```bash
  grep "^>" sequences.fasta | wc -l
  ```

- **Verifying the number of lines in a data file:**

  ```bash
  wc -l data.csv
  ```

---

### ** The `nl` Command**

#### ** Introduction to `nl`**

The `nl` command numbers the lines of a file.

**Key Features:**

- **Number lines with customizable formatting.**
- **Options to number only non-empty lines.**

#### ** Basic Syntax**

```bash
nl [OPTIONS] [FILE]
```

#### ** Commonly Used Options**

- **`-b TYPE`**: Set body numbering style.
  - **`-b a`**: Number all lines.
  - **`-b t`**: Number non-empty lines (default).
- **`-n FORMAT`**: Set numbering format.
  - **`-n ln`**: Left justified.
  - **`-n rn`**: Right justified (default).
  - **`-n rz`**: Right justified with leading zeros.
- **`-w NUMBER`**: Set the width of the line numbers.

#### ** Examples**

- **Number non-empty lines (default behavior):**

  ```bash
  nl file.txt
  ```

- **Number all lines including empty ones:**

  ```bash
  nl -b a file.txt
  ```

- **Left-justify line numbers with a width of 4:**

  ```bash
  nl -n ln -w 4 file.txt
  ```

#### ** Practical Applications**

- **Creating numbered lists from a text file.**

- **Preparing code snippets with line numbers for documentation.**

---

### ** The `sort` Command**

#### ** Introduction to `sort`**

The `sort` command sorts lines of text files.

**Key Features:**

- **Sort data alphabetically or numerically.**
- **Supports sorting by specific fields.**

#### **5.9.2 Basic Syntax**

```bash
sort [OPTIONS] [FILE...]
```

#### ** Commonly Used Options**

- **`-n`**: Sort numerically.
- **`-r`**: Reverse the sorting order.
- **`-k FIELD`**: Sort based on the specified field.
- **`-t CHAR`**: Use `CHAR` as the field separator.
- **`-u`**: Output only the first of an equal run.

#### ** Examples**

- **Sort a file alphabetically:**

  ```bash
  sort names.txt
  ```

- **Sort a file numerically:**

  ```bash
  sort -n numbers.txt
  ```

- **Sort in reverse order:**

  ```bash
  sort -r names.txt
  ```

- **Sort a CSV file based on the second field:**

  ```bash
  sort -t ',' -k2 data.csv
  ```

- **Sort and remove duplicates:**

  ```bash
  sort -u names.txt
  ```

#### ** Practical Applications**

- **Sorting data files for analysis.**

- **Preparing lists in a specific order.**

---

### ** The `diff` Command**

#### ** Introduction to `diff`**

The `diff` command compares files line by line.

**Key Features:**

- **Identify differences between files.**
- **Useful for tracking changes or comparing outputs.**

#### ** Basic Syntax**

```bash
diff [OPTIONS] FILE1 FILE2
```

#### ** Commonly Used Options**

- **`-u`** or **`--unified`**: Show unified diff format.
- **`-c`** or **`--context`**: Show context diff format.
- **`-y`** or **`--side-by-side`**: Output in two columns.
- **`--color`**: Colorize the output.

#### ** Examples**

- **Compare two files:**

  ```bash
  diff file1.txt file2.txt
  ```

- **Show differences in unified format:**

  ```bash
  diff -u file1.txt file2.txt
  ```

- **Side-by-side comparison:**

  ```bash
  diff -y file1.txt file2.txt
  ```

- **Ignore whitespace differences:**

  ```bash
  diff -w file1.txt file2.txt
  ```

#### ** Practical Applications**

- **Code reviews to see changes between versions.**

- **Comparing configuration files for discrepancies.**

---

### ** Combining Commands for Powerful Text Processing**

The true power of Linux command-line tools emerges when combining them to perform complex tasks.

#### **Example 1: Viewing Specific Parts of Logs**

- **Display the last 100 lines of a log file and search for "ERROR":**

  ```bash
  tail -n 100 application.log | grep "ERROR"
  ```

#### **Example 2: Counting Unique Entries**

- **Count the number of unique IP addresses in a log file:**

  ```bash
  awk '{ print $1 }' access.log | sort | uniq | wc -l
  ```

#### **Example 3: Extracting and Formatting Data**

- **Extract specific columns from a CSV file and format the output:**

  ```bash
  cut -d',' -f1,3 data.csv | column -s',' -t
  ```

#### **Example 4: Monitoring Real-Time Data**

- **Monitor a log file and highlight occurrences of "ERROR":**

  ```bash
  tail -f application.log | grep --color=auto "ERROR"
  ```

---



Working with text files is an integral part of bioinformatics. Whether you're processing genome sequences, analyzing data logs, or manipulating configuration files, the ability to efficiently handle and modify text files is essential. Linux provides powerful command-line tools for these tasks, including `grep`, `sed`, `awk`, and `vim`. This section will provide an exhaustive description of each tool, their functionalities, and practical examples to help you master text file handling and modification.

---

## ** The `grep` Command**

### ** Introduction to `grep`**

The `grep` command is used for searching plain-text data for lines that match a regular expression. The name stands for **Global Regular Expression Print**.

**Key Features:**

- Search files for lines containing a match to the given pattern.
- Supports regular expressions for complex pattern matching.
- Can search multiple files and directories recursively.

### ** Basic Syntax**

```bash
grep [OPTIONS] PATTERN [FILE...]
```

- **`PATTERN`**: The search pattern, which can be a simple string or a regular expression.
- **`FILE...`**: One or more files to search. If no files are specified, `grep` reads from standard input.

### ** Commonly Used Options**

- **`-i`** or **`--ignore-case`**: Ignore case distinctions in patterns and input data.

  ```bash
  grep -i "gene" annotations.gff
  ```

- **`-v`** or **`--invert-match`**: Select non-matching lines.

  ```bash
  grep -v "chrM" alignments.sam
  ```

- **`-c`** or **`--count`**: Suppress normal output; instead, print a count of matching lines for each input file.

  ```bash
  grep -c "ATG" sequences.fasta
  ```

- **`-n`** or **`--line-number`**: Prefix each line of output with the line number within its input file.

  ```bash
  grep -n "error" log.txt
  ```

- **`-r`** or **`--recursive`**: Read all files under each directory recursively.

  ```bash
  grep -r "motif" data/
  ```

- **`-l`** or **`--files-with-matches`**: Suppress normal output; instead, print the name of each input file from which output would normally have been printed.

  ```bash
  grep -l "pattern" *.txt
  ```

- **`-w`** or **`--word-regexp`**: Select only those lines containing matches that form whole words.

  ```bash
  grep -w "gene" annotations.gff
  ```

- **`-x`** or **`--line-regexp`**: Select only those matches that exactly match the whole line.

  ```bash
  grep -x "ATGCGT" sequences.fasta
  ```

- **`-E`** or **`--extended-regexp`**: Interpret PATTERN as an extended regular expression (ERE).

  ```bash
  grep -E "gene|transcript" annotations.gff
  ```

### ** Regular Expressions in `grep`**

Regular expressions (regex) are sequences of characters that define search patterns. They are extremely powerful for matching complex patterns.

#### **Basic Regular Expression Characters**

- **`.`**: Matches any single character.

  ```bash
  grep "c.t" words.txt
  ```

- **`^`**: Matches the beginning of a line.

  ```bash
  grep "^ATG" sequences.fasta
  ```

- **`$`**: Matches the end of a line.

  ```bash
  grep "end$" sentences.txt
  ```

- **`*`**: Matches zero or more occurrences of the preceding element.

  ```bash
  grep "A*T" sequences.fasta
  ```

- **`[]`**: Matches any one of the characters inside the brackets.

  ```bash
  grep "[GC]" sequences.fasta
  ```

- **`[^]`**: Matches any character not inside the brackets.

  ```bash
  grep "[^GC]" sequences.fasta
  ```

- **`\`**: Escape character, used to match special characters.

  ```bash
  grep "\$100" prices.txt
  ```

#### **Extended Regular Expressions (with `-E` Option)**

- **`+`**: Matches one or more occurrences of the preceding element.

  ```bash
  grep -E "A+T" sequences.fasta
  ```

- **`?`**: Matches zero or one occurrence of the preceding element.

  ```bash
  grep -E "colou?r" words.txt
  ```

- **`|`**: Logical OR between patterns.

  ```bash
  grep -E "gene|transcript" annotations.gff
  ```

- **`()`**: Groups regular expressions.

  ```bash
  grep -E "(ATG){2}" sequences.fasta
  ```

#### **Examples of Regular Expression Usage**

- **Find lines that start with a number:**

  ```bash
  grep "^[0-9]" data.txt
  ```

- **Find empty lines:**

  ```bash
  grep "^$" file.txt
  ```

- **Find lines that contain exactly three characters:**

  ```bash
  grep "^...$" words.txt
  ```

- **Find lines where "gene" is at the end of the line:**

  ```bash
  grep "gene$" annotations.gff
  ```

### ** Context Control Options**

- **`-A NUM`** or **`--after-context=NUM`**: Print NUM lines of trailing context after matching lines.

  ```bash
  grep -A 2 "gene" annotations.gff
  ```

- **`-B NUM`** or **`--before-context=NUM`**: Print NUM lines of leading context before matching lines.

  ```bash
  grep -B 2 "gene" annotations.gff
  ```

- **`-C NUM`** or **`--context=NUM`**: Print NUM lines of output context.

  ```bash
  grep -C 2 "gene" annotations.gff
  ```

### ** Additional Useful Options**

- **`-H`** or **`--with-filename`**: Print the filename for each match.

- **`-h`** or **`--no-filename`**: Suppress the prefixing of filenames on output.

- **`--color[=WHEN]`**: Mark up the matching text with color.

  ```bash
  grep --color=auto "pattern" file.txt
  ```

- **`-m NUM`** or **`--max-count=NUM`**: Stop reading a file after NUM matching lines.

  ```bash
  grep -m 5 "pattern" file.txt
  ```

### ** Using `grep` with Pipes and Redirection**

`grep` is often used in combination with other commands using pipes (`|`).

**Example: Search running processes for a specific program:**

```bash
ps aux | grep "python"
```

**Example: Find lines containing "error" and redirect output to a file:**

```bash
grep "error" log.txt > errors_found.txt
```

### ** Practical Examples**

- **Count the number of sequences in a FASTA file (headers start with '>'):**

  ```bash
  grep -c "^>" sequences.fasta
  ```

- **Find all occurrences of "ATG" in multiple FASTA files:**

  ```bash
  grep -H "ATG" *.fasta
  ```

- **Search recursively for files containing "ERROR" in the current directory:**

  ```bash
  grep -r "ERROR" .
  ```

- **List all files that do not contain the word "deprecated":**

  ```bash
  grep -L "deprecated" *.txt
  ```

- **Display line numbers for matches:**

  ```bash
  grep -n "pattern" file.txt
  ```

### ** Exit Status of `grep`**

`grep` returns different exit statuses based on the search result:

- **0**: One or more lines were selected.
- **1**: No lines were selected.
- **2**: An error occurred.

This can be useful in scripts:

```bash
if grep -q "pattern" file.txt; then
    echo "Pattern found."
else
    echo "Pattern not found."
fi
```

### ** Tips and Best Practices**

- **Quoting Patterns**: Always quote your patterns to prevent the shell from interpreting special characters.

  ```bash
  grep 'pattern' file.txt
  ```

- **Use Anchors**: Use `^` and `$` to match patterns at the beginning or end of lines.

- **Combine Options**: Options can be combined for more powerful searches.

  ```bash
  grep -rin "pattern" .
  ```

- **Use `/dev/null` Trick**: When searching multiple files, to force `grep` to prefix the filename even if only one file is searched.

  ```bash
  grep "pattern" file.txt /dev/null
  ```

---

## **Part : The `vim` Editor**

### ** Introduction to `vim`**

`vim` (Vi IMproved) is an advanced text editor that seeks to provide the power of the de facto Unix editor 'Vi', with a more complete feature set. It is highly configurable and efficient, making it a favorite among developers and system administrators.

### ** Starting `vim`**

```bash
vim [OPTIONS] [FILE...]
```

**Examples:**

- **Open a file:**

  ```bash
  vim myscript.sh
  ```

- **Open multiple files:**

  ```bash
  vim file1.txt file2.txt
  ```

### ** Modes in `vim`**

`vim` is a modal editor, which means it has different modes for different operations.

#### ** Normal Mode**

- **Default mode when starting `vim`.**
- Used for navigation and issuing commands.
- Press `Esc` to return to Normal Mode from any other mode.

#### ** Insert Mode**

- **Used for inserting text.**
- Entered by pressing `i`, `a`, `o`, etc.
- Press `Esc` to return to Normal Mode.

#### ** Visual Mode**

- **Used for selecting text.**
- Entered by pressing `v` (character-wise), `V` (line-wise), or `Ctrl + v` (block-wise) from Normal Mode.
- Once selected, operations can be performed on the selection.

#### ** Command-Line Mode**

- **Used for executing commands, searching, and substitutions.**
- Entered by pressing `:`, `/`, or `?` in Normal Mode.

### ** Navigation Commands**

#### **Basic Cursor Movements**

- **`h`**: Move left.
- **`j`**: Move down.
- **`k`**: Move up.
- **`l`**: Move right.

#### **Word Movements**

- **`w`**: Jump to the start of the next word.
- **`b`**: Jump to the start of the previous word.
- **`e`**: Jump to the end of the current word.

#### **Line Movements**

- **`0`** or **`^`**: Move to the beginning of the line.
- **`$`**: Move to the end of the line.
- **`gg`**: Go to the first line of the file.
- **`G`**: Go to the last line of the file.
- **`nG`**: Go to line number `n`.

#### **Screen Movements**

- **`Ctrl + f`**: Move forward one screen.
- **`Ctrl + b`**: Move backward one screen.
- **`Ctrl + d`**: Move down half a screen.
- **`Ctrl + u`**: Move up half a screen.

#### **Scrolling**

- **`zz`**: Center the screen on the current line.
- **`zt`**: Scroll so the current line is at the top.
- **`zb`**: Scroll so the current line is at the bottom.

### ** Editing Text**

#### **Entering Insert Mode**

- **`i`**: Insert before the cursor.
- **`I`**: Insert at the beginning of the line.
- **`a`**: Append after the cursor.
- **`A`**: Append at the end of the line.
- **`o`**: Open a new line below the current line.
- **`O`**: Open a new line above the current line.
- **`s`**: Delete the character under the cursor and enter Insert Mode.
- **`S`**: Delete the current line and enter Insert Mode.

#### **Deleting Text**

- **`x`**: Delete the character under the cursor.
- **`X`**: Delete the character before the cursor.
- **`dd`**: Delete the current line.
- **`dw`**: Delete from the cursor to the end of the word.
- **`d$`**: Delete from the cursor to the end of the line.
- **`d0`**: Delete from the cursor to the beginning of the line.
- **`dG`**: Delete from the current line to the end of the file.
- **`ndd`**: Delete `n` lines.

#### **Yanking (Copying) and Pasting**

- **`yy`** or **`Y`**: Yank (copy) the current line.
- **`nyy`**: Yank `n` lines.
- **`yw`**: Yank from the cursor to the end of the word.
- **`y$`**: Yank from the cursor to the end of the line.
- **`p`**: Paste after the cursor or below the current line.
- **`P`**: Paste before the cursor or above the current line.

#### **Changing Text**

- **`c`**: Change command works like delete but leaves you in Insert Mode.
- **`cw`**: Change word from the cursor to the end.
- **`c$`**: Change to the end of the line.
- **`cc`**: Change (replace) the entire line.

#### **Undo and Redo**

- **`u`**: Undo the last change.
- **`Ctrl + r`**: Redo the undone changes.

### ** Searching and Substitutions**

#### **Searching**

- **Search Forward:**

  ```vim
  /pattern
  ```

- **Search Backward:**

  ```vim
  ?pattern
  ```

- **Repeat Search Forward:**

  ```vim
  n
  ```

- **Repeat Search Backward:**

  ```vim
  N
  ```

#### **Substitutions**

- **Basic Substitute Command:**

  ```vim
  :s/old/new/
  ```

  Replaces the first occurrence of "old" with "new" on the current line.

- **Replace All Occurrences on the Current Line:**

  ```vim
  :s/old/new/g
  ```

- **Replace in the Entire File:**

  ```vim
  :%s/old/new/g
  ```

- **Confirm Each Replacement:**

  ```vim
  :%s/old/new/gc
  ```

- **Substitute in a Range of Lines:**

  ```vim
  :10,20s/old/new/g
  ```

#### **Using Regular Expressions**

- **Match Start of Line:**

  ```vim
  /^pattern
  ```

- **Match End of Line:**

  ```vim
  /pattern$
  ```

- **Use Wildcards:**

  ```vim
  /pat.*ern
  ```

### **4.7 Visual Mode Operations**

#### **Selecting Text**

- **Character-wise Selection:**

  ```vim
  v
  ```

- **Line-wise Selection:**

  ```vim
  V
  ```

- **Block-wise Selection:**

  ```vim
  Ctrl + v
  ```

#### **Operations on Selected Text**

- **Delete:**

  ```vim
  d
  ```

- **Yank (Copy):**

  ```vim
  y
  ```

- **Change (Delete and Enter Insert Mode):**

  ```vim
  c
  ```

- **Indent Right:**

  ```vim
  >
  ```

- **Indent Left:**

  ```vim
  <
  ```

- **Uppercase:**

  ```vim
  U
  ```

- **Lowercase:**

  ```vim
  u
  ```

### ** Working with Multiple Files**

#### **Buffers**

- **List Open Buffers:**

  ```vim
  :ls
  ```

- **Switch to Buffer `n`:**

  ```vim
  :b n
  ```

#### **Tabs**

- **Open a New Tab:**

  ```vim
  :tabnew filename
  ```

- **Switch to Next Tab:**

  ```vim
  gt
  ```

- **Switch to Previous Tab:**

  ```vim
  gT
  ```

#### **Splits**

- **Horizontal Split:**

  ```vim
  :split filename
  ```

- **Vertical Split:**

  ```vim
  :vsplit filename
  ```

- **Navigate Between Splits:**

  - **Up:** `Ctrl + w k`
  - **Down:** `Ctrl + w j`
  - **Left:** `Ctrl + w h`
  - **Right:** `Ctrl + w l`

### ** Macros and Recording**

#### **Recording a Macro**

- **Start Recording into Register `a`:**

  ```vim
  qa
  ```

- **Perform the Actions to Record**

- **Stop Recording:**

  ```vim
  q
  ```

#### **Playing a Macro**

- **Execute Macro in Register `a`:**

  ```vim
  @a
  ```

- **Execute Macro `n` Times:**

  ```vim
  n@a
  ```

### ** Customization with `.vimrc`**

#### **Sample `.vimrc` Settings**

- **Enable Syntax Highlighting:**

  ```vim
  syntax on
  ```

- **Set Line Numbers:**

  ```vim
  set number
  ```

- **Set Relative Line Numbers:**

  ```vim
  set relativenumber
  ```

- **Enable Mouse Support:**

  ```vim
  set mouse=a
  ```

- **Set Tab Width to 4 Spaces:**

  ```vim
  set tabstop=4
  set shiftwidth=4
  set expandtab
  ```

- **Show Matching Parentheses:**

  ```vim
  set showmatch
  ```

### ** Plugins and Extensions**

#### **Using Plugin Managers**

- **Vundle**: Vim plugin manager for installing and managing plugins.

- **Install Vundle:**

  ```bash
  git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim
  ```

- **Configure `.vimrc` for Vundle:**

  ```vim
  set nocompatible
  filetype off

  set rtp+=~/.vim/bundle/Vundle.vim
  call vundle#begin()
  Plugin 'VundleVim/Vundle.vim'

  " Add Plugins here
  Plugin 'scrooloose/nerdtree'  " File Explorer
  Plugin 'tpope/vim-fugitive'   " Git Integration
  Plugin 'vim-airline/vim-airline'  " Status Bar

  call vundle#end()
  filetype plugin indent on
  ```

- **Install Plugins:**

  Open Vim and run:

  ```vim
  :PluginInstall
  ```

#### **Popular Plugins**

- **NERDTree**: A file system explorer for the Vim editor.

  - **Open NERDTree:**

    ```vim
    :NERDTreeToggle
    ```

- **vim-airline**: Lean and mean status/tabline for Vim that's light as air.

- **ctrlp.vim**: Full path fuzzy file, buffer, mru, tag, etc. finder.

- **syntastic**: Syntax checking hacks for Vim.

### ** Tips for Efficient Vim Usage**

- **Practice Touch Typing**: Familiarity with the keyboard enhances speed.

- **Learn the Commands**: The more commands you know, the more efficient you'll be.

- **Use Marks and Jumps**: Navigate quickly within files.

  - **Set Mark `a`:**

    ```vim
    ma
    ```

  - **Jump to Mark `a`:**

    ```vim
    'a
    ```

- **Use Buffers Effectively**: Switch between multiple files seamlessly.

- **Customize Your Environment**: Tailor Vim to suit your workflow.

### ** Resources for Learning Vim**

- **Vim Tutor**: An interactive tutorial.

  ```bash
  vimtutor
  ```

- **Books and Online Guides:**

  - "Practical Vim" by Drew Neil
  - "Learning the vi and Vim Editors" by Arnold Robbins
  - [Vim Tips Wiki](http://vim.wikia.com/wiki/Vim_Tips_Wiki)
  - [Vim Adventures](https://vim-adventures.com/): A game for learning Vim.

---
## ** The `sed` Command**

### ** Introduction to `sed`**

`sed` stands for **Stream Editor**. It's used to perform basic text transformations on an input stream (a file or input from a pipeline). `sed` can execute complex editing commands, and it is particularly powerful when used in scripts.

### ** Basic Syntax**

```bash
sed [OPTIONS] 'SCRIPT' [INPUTFILE...]
```

- **`SCRIPT`**: A set of instructions to apply to the input.
- **`INPUTFILE`**: The file(s) to process. If none are specified, `sed` reads from standard input.

### ** Commonly Used Options**

- **`-e SCRIPT`**: Add the `SCRIPT` to the commands to be executed.
- **`-f SCRIPTFILE`**: Add the contents of `SCRIPTFILE` to the commands to be executed.
- **`-n`**: Suppress automatic printing of pattern space.
- **`-i[SUFFIX]`**: Edit files in-place, optionally creating a backup with `SUFFIX`.

### ** The `sed` Editing Commands**

#### ** The Substitute Command (`s`)**

The most commonly used `sed` command is the substitute command, which replaces occurrences of a pattern with a replacement.

**Syntax:**

```bash
s/REGEX/REPLACEMENT/FLAGS
```

**Flags:**

- **`g`**: Global replacement in the line.
- **`i`**: Case-insensitive matching.
- **`p`**: Print the line if a substitution was made.
- **`number`**: Replace only the nth occurrence in the line.

**Examples:**

- **Replace the first occurrence of "old" with "new":**

  ```bash
  sed 's/old/new/' file.txt
  ```

- **Replace all occurrences of "old" with "new":**

  ```bash
  sed 's/old/new/g' file.txt
  ```

- **Replace only the second occurrence of "old":**

  ```bash
  sed 's/old/new/2' file.txt
  ```

- **Replace "old" with "new" case-insensitively:**

  ```bash
  sed 's/old/new/Ig' file.txt
  ```

#### ** Addressing**

`sed` allows you to specify addresses to limit where the commands apply.

**Address Types:**

- **Line Numbers**: Apply the command to specific line numbers.

  ```bash
  sed '3s/old/new/' file.txt
  ```

- **Ranges**: Apply the command to a range of lines.

  ```bash
  sed '10,20s/old/new/' file.txt
  ```

- **Patterns**: Apply the command to lines matching a pattern.

  ```bash
  sed '/pattern/s/old/new/' file.txt
  ```

- **Combination**: Apply the command between lines matching two patterns.

  ```bash
  sed '/start_pattern/,/end_pattern/s/old/new/' file.txt
  ```

#### ** Deletion (`d` command)**

Deletes lines from the input.

- **Delete line 5:**

  ```bash
  sed '5d' file.txt
  ```

- **Delete lines matching a pattern:**

  ```bash
  sed '/^$/d' file.txt  # Delete empty lines
  ```

- **Delete a range of lines:**

  ```bash
  sed '10,20d' file.txt
  ```

#### ** Insertion and Appending**

- **Insert text before a line (`i` command):**

  ```bash
  sed '3i\Inserted line' file.txt
  ```

- **Append text after a line (`a` command):**

  ```bash
  sed '3a\Appended line' file.txt
  ```

#### ** Changing Lines (`c` command)**

Replaces the entire line(s) with new text.

- **Change line 5:**

  ```bash
  sed '5c\New content' file.txt
  ```

#### ** Transform Characters (`y` command)**

Transliterate characters (like the `tr` command).

- **Convert lowercase to uppercase:**

  ```bash
  sed 'y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' file.txt
  ```

#### ** Printing (`p` command)**

- **Print lines matching a pattern:**

  ```bash
  sed -n '/pattern/p' file.txt
  ```

- **Print line numbers:**

  ```bash
  sed '=' file.txt
  ```

### ** Using Hold and Pattern Spaces**

`sed` uses two workspaces: the **pattern space** and the **hold space**.

- **Pattern Space**: Where the current line is stored and modified.
- **Hold Space**: A secondary storage space for temporary data.

**Commands:**

- **`h`**: Copy pattern space to hold space.
- **`H`**: Append pattern space to hold space.
- **`g`**: Copy hold space to pattern space.
- **`G`**: Append hold space to pattern space.
- **`x`**: Exchange the contents of pattern and hold spaces.

**Example: Swap adjacent lines:**

```bash
sed 'N; s/\(.*\)\n\(.*\)/\2\n\1/' file.txt
```

### ** In-Place Editing with `-i` Option**

Modify files directly without the need for temporary files.

- **Edit file in-place:**

  ```bash
  sed -i 's/old/new/g' file.txt
  ```

- **Create a backup while editing:**

  ```bash
  sed -i.bak 's/old/new/g' file.txt
  ```

  This creates a backup file named `file.txt.bak`.

### ** Using Multiple Commands**

You can execute multiple `sed` commands by:

- **Using `-e` option:**

  ```bash
  sed -e 'command1' -e 'command2' file.txt
  ```

- **Using semicolons to separate commands:**

  ```bash
  sed 'command1; command2' file.txt
  ```

- **Using a script file with `-f` option:**

  ```bash
  sed -f script.sed file.txt
  ```

**Example:**

```bash
sed -e '/^$/d' -e 's/old/new/g' file.txt
```

### ** Regular Expressions in `sed`**

`sed` supports regular expressions similar to `grep`.

- **Matching patterns:**

  ```bash
  sed -n '/^gene/p' annotations.gff
  ```

- **Using backreferences:**

  ```bash
  sed 's/\(gene\)\s\+\(.*\)/\1:\2/' annotations.gff
  ```

### ** Examples and Practical Applications**

#### **Example 1: Substitute Tabs with Commas**

```bash
sed 's/\t/,/g' data.tsv > data.csv
```

#### **Example 2: Delete All Comments (Lines Starting with '#')**

```bash
sed '/^#/d' script.sh
```

#### **Example 3: Add Line Numbers to a File**

```bash
sed = file.txt | sed 'N; s/\n/\t/'
```

#### **Example 4: Replace Multiple Spaces with a Single Space**

```bash
sed 's/  */ /g' file.txt
```

#### **Example 5: Extract a Range of Lines**

Extract lines from line number 10 to 20:

```bash
sed -n '10,20p' file.txt
```

#### **Example 6: Insert Text After a Pattern**

Insert "NEW LINE" after lines containing "pattern":

```bash
sed '/pattern/a\NEW LINE' file.txt
```

---


## **Part : The `awk` Command**

### **Introduction to `awk`**

`awk` is a powerful text-processing programming language. Named after its creators Aho, Weinberger, and Kernighan, `awk` is designed for data extraction and reporting.

**Key Features:**

- Pattern scanning and processing language.
- Works on each line of a file.
- Ideal for handling delimited text files (like CSV, TSV).
- Supports variables, functions, and control flow statements.

### ** Basic Syntax**

```bash
awk 'PROGRAM' FILE
```

- **`PROGRAM`**: Contains patterns and actions.
- **`FILE`**: Input file(s) to process.

**Example:**

```bash
awk '{ print }' file.txt
```

This prints each line of `file.txt`.

### ** Structure of an `awk` Program**

An `awk` program consists of patterns and actions:

```awk
pattern { action }
```

- **Pattern**: Specifies when the action is performed.
- **Action**: Enclosed in `{}`; what to do when the pattern matches.

### ** Fields and Records**

- **Record**: By default, each line is a record (`NR` is the record number).
- **Field**: Each word in a line (`$1`, `$2`, ..., `$NF` for the last field).

**Field Separator:**

- Default is any whitespace.
- Can be changed using the `-F` option or by setting `FS` variable.

**Example:**

```bash
awk -F ',' '{ print $1 }' data.csv
```

### ** Built-in Variables**

- **`NR`**: Current record number.
- **`NF`**: Number of fields in the current record.
- **`FS`**: Field separator.
- **`OFS`**: Output field separator.
- **`RS`**: Input record separator.
- **`ORS`**: Output record separator.
- **`FILENAME`**: Name of the current input file.
- **`$0`**: The entire input record.

### ** Operators and Expressions**

`awk` supports arithmetic and string operations:

- **Arithmetic Operators**: `+`, `-`, `*`, `/`, `%`, `^`
- **Assignment Operators**: `=`, `+=`, `-=`, etc.
- **Comparison Operators**: `==`, `!=`, `<`, `>`, `<=`, `>=`
- **Logical Operators**: `&&` (and), `||` (or), `!` (not)
- **Regular Expression Matching**: `~` (matches), `!~` (does not match)

**Examples:**

- **Print lines where the second field is greater than 100:**

  ```bash
  awk '$2 > 100' data.txt
  ```

- **Print lines where the third field matches "gene":**

  ```bash
  awk '$3 == "gene"' annotations.gff
  ```

### ** Control Flow Statements**

#### **If Statements**

```awk
if (condition) {
    actions
} else {
    other_actions
}
```

**Example:**

```bash
awk '{ if ($2 > 100) print $0 }' data.txt
```

#### **Loops**

- **For Loop:**

  ```awk
  for (i = 1; i <= NF; i++) {
      print $i
  }
  ```

- **While Loop:**

  ```awk
  while (condition) {
      actions
  }
  ```

- **Do-While Loop:**

  ```awk
  do {
      actions
  } while (condition)
  ```

### ** User-Defined Functions**

You can define your own functions in `awk`.

**Example:**

```awk
function add(a, b) {
    return a + b
}

awk 'BEGIN { print add(5, 3) }'
```

### ** Built-in Functions**

#### **String Functions**

- **`length([string])`**: Returns the length of the string.
- **`substr(string, start, [length])`**: Returns a substring.
- **`index(string, substring)`**: Returns the position of `substring` in `string`.
- **`split(string, array, [separator])`**: Splits `string` into `array`.

**Example:**

```bash
awk '{ print length($0) }' file.txt
```

#### **Mathematical Functions**

- **`sin(x)`, `cos(x)`, `sqrt(x)`, `exp(x)`, `log(x)`**
- **`int(x)`**: Returns the integer part of `x`.
- **`rand()`**: Returns a random number between 0 and 1.
- **`srand([x])`**: Seeds the random number generator.

**Example:**

```bash
awk 'BEGIN { srand(); print rand() }'
```

#### **Time Functions**

- **`strftime(format, [timestamp])`**: Formats the date/time.

**Example:**

```bash
awk 'BEGIN { print strftime("%Y-%m-%d %H:%M:%S") }'
```

### ** Processing Multiple Files**

`awk` can process multiple files and uses `FILENAME` and `FNR` variables:

- **`FNR`**: Record number in the current file.
- **`NR`**: Total record number across all files.

**Example:**

```bash
awk '{ print FILENAME, FNR, $0 }' file1.txt file2.txt
```

### ** Changing the Field Separator**

- **Using `-F` option:**

  ```bash
  awk -F ',' '{ print $1 }' data.csv
  ```

- **Setting `FS` variable inside the script:**

  ```bash
  awk 'BEGIN { FS = "," } { print $1 }' data.csv
  ```

### ** Examples and Practical Applications**

#### **Example 1: Sum Values in a Column**

```bash
awk '{ sum += $2 } END { print "Total:", sum }' data.txt
```

#### **Example 2: Calculate Average**

```bash
awk '{ sum += $3 } END { if (NR > 0) print "Average:", sum / NR }' data.txt
```

#### **Example 3: Print Lines with More Than 5 Fields**

```bash
awk 'NF > 5' data.txt
```

#### **Example 4: Extract Specific Columns and Reorder**

```bash
awk '{ print $3, $1 }' data.txt
```

#### **Example 5: Convert FASTQ to FASTA**

```bash
awk 'NR%4==1 { print ">" substr($0,2) } NR%4==2 { print }' sequences.fastq > sequences.fasta
```

#### **Example 6: Conditional Data Processing**

```bash
awk '{
    if ($2 > 1000) {
        print $1, "High", $2
    } else {
        print $1, "Low", $2
    }
}' data.txt
```

---



## **Conclusion**

In this expanded section, we've explored additional fundamental commands for text file handling and modification:

- **`touch`**: Creating empty files and updating timestamps.
- **`cat`**: Viewing and concatenating file contents.
- **`head`** and **`tail`**: Displaying the beginning and end of files.
- **`less`** and **`more`**: Paging through text files.
- **`wc`**: Counting lines, words, and characters.
- **`nl`**: Numbering lines in files.
- **`sort`**: Sorting text data.
- **`diff`**: Comparing files.

These tools are essential for daily tasks in Linux, especially in bioinformatics where data manipulation and text processing are frequent. By mastering these commands, you can efficiently manage and analyze text files, streamline your workflows, and automate complex tasks.

---

## **Additional Resources**

- **GNU Coreutils Manual**: Detailed documentation on basic file operations.

  - [GNU Coreutils](https://www.gnu.org/software/coreutils/manual/coreutils.html)

- **Linux Documentation Project**: Guides and HOWTOs on various Linux topics.

  - [Linux Documentation Project](https://www.tldp.org/)

- **Advanced Bash-Scripting Guide**: Comprehensive guide on shell scripting.

  - [Advanced Bash-Scripting Guide](https://tldp.org/LDP/abs/html/)

---


**Final Thought**: The command line might seem daunting at first, but with practice, it becomes a powerful ally in managing and manipulating data efficiently. Keep exploring and experimenting with these commands to unlock their full potential!

